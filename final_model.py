# -*- coding: utf-8 -*-
"""final_model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PT5XpY3d95Tnimass16VKL_rlyXoUeDx
"""

!apt-get install -y -qq software-properties-common python-software-properties module-init-tools
!add-apt-repository -y ppa:alessandro-strada/ppa 2>&1 > /dev/null
!apt-get update -qq 2>&1 > /dev/null
!apt-get -y install -qq google-drive-ocamlfuse fuse
from google.colab import auth
auth.authenticate_user()
from oauth2client.client import GoogleCredentials
creds = GoogleCredentials.get_application_default()
import getpass
!google-drive-ocamlfuse -headless -id={creds.client_id} -secret={creds.client_secret} < /dev/null 2>&1 | grep URL
vcode = getpass.getpass()
!echo {vcode} | google-drive-ocamlfuse -headless -id={creds.client_id} -secret={creds.client_secret}

!mkdir -p drive
!google-drive-ocamlfuse drive

cd drive/project_data/final_pascal_npy_datas

pwd

import keras
from keras.models import Sequential,load_model
from keras import layers, Model,Input
from keras.layers.normalization import BatchNormalization
from keras import optimizers
import numpy as np
import tensorflow as tf
from keras.optimizers import Adam
from keras import backend as K
from keras.layers.merge import concatenate
from keras.layers.advanced_activations import LeakyReLU
from keras.preprocessing import image

boxes = 3
classes = 20
true_boxes  = Input(shape=(9,9,3,4))

img_input = Input(shape=(300, 300, 3))

# VGG-16
x = layers.Conv2D(64, (3, 3),
                  activation='relu',
                  padding='same',
                  name='block1_conv1',
                  trainable=False)(img_input)
x = layers.Conv2D(64, (3, 3),
                  activation='relu',
                  padding='same',
                  name='block1_conv2',
                  trainable=False)(x)
x = layers.MaxPooling2D((2, 2), strides=(2, 2), name='block1_pool')(x)

# Block 2
x = layers.Conv2D(128, (3, 3),
                  activation='relu',
                  padding='same',
                  name='block2_conv1',
                  trainable=False)(x)
x = layers.Conv2D(128, (3, 3),
                  activation='relu',
                  padding='same',
                  name='block2_conv2',
                  trainable=False)(x)
x = layers.MaxPooling2D((2, 2), strides=(2, 2), name='block2_pool')(x)

# Block 3
x = layers.Conv2D(256, (3, 3),
                  activation='relu',
                  padding='same',
                  name='block3_conv1',
                  trainable=False)(x)
x = layers.Conv2D(256, (3, 3),
                  activation='relu',
                  padding='same',
                  name='block3_conv2',
                  trainable=False)(x)
x = layers.Conv2D(256, (3, 3),
                  activation='relu',
                  padding='same',
                  name='block3_conv3',
                  trainable=False)(x)
x = layers.MaxPooling2D((2, 2), strides=(2, 2), name='block3_pool')(x)

# Block 4
x = layers.Conv2D(512, (3, 3),
                  activation='relu',
                  padding='same',
                  name='block4_conv1',
                  trainable=False)(x)
x = layers.Conv2D(512, (3, 3),
                  activation='relu',
                  padding='same',
                  name='block4_conv2',
                  trainable=False)(x)
x = layers.Conv2D(512, (3, 3),
                  activation='relu',
                  padding='same',
                  name='block4_conv3',
                  trainable=False)(x)
x = layers.MaxPooling2D((2, 2), strides=(2, 2), name='block4_pool')(x)

# Block 5
x = layers.Conv2D(512, (3, 3),
                  activation='relu',
                  padding='same',
                  name='block5_conv1',
                  trainable=False)(x)
x = layers.Conv2D(512, (3, 3),
                  activation='relu',
                  padding='same',
                  name='block5_conv2',
                  trainable=False)(x)
x = layers.Conv2D(512, (3, 3),
                  activation='relu',
                  padding='same',
                  name='block5_conv3',
                  trainable=False)(x)
classifier_output = layers.MaxPooling2D((2, 2), strides=(2, 2), name='block5_pool')(x)
# VGG-Output
#skip connection
bypass = classifier_output

#detector block 1
output = layers.Conv2D(512, (1, 1),
                  activation='relu',
                  padding='same',
                  name='detector_block_1_1')(classifier_output)
output = layers.Conv2D(512, (1, 1),
                  activation='relu',
                  padding='same',
                  name='detector_block_1_2')(output)
#Merging
output = concatenate([bypass,output])
#detector block 2
output = layers.Conv2D(512, (2, 2),
                  activation='relu',
                  padding='same',
                  name='detector_block_2_1')(output)
output = layers.Conv2D(256, (2, 2),
                  activation='relu',
                  padding='same',
                  name='detector_block_2_2')(output)

## Comment the class= 0 for classification along with detection

classes = 0
output = BatchNormalization(name='detector_block_2_norm')(output)
output = LeakyReLU(alpha=0.1)(output)
output = layers.Conv2D(boxes * (4 + 1 + classes),(1,1),
                padding='same',
                name='detector_block_2_3')(output)
output = layers.Reshape((9, 9, boxes, 4 + 1 + classes))(output)

output = layers.Lambda(lambda args: args[0])([output, true_boxes])

output = layers.Dense(5,name = "Fc_after_1")(output)

output = layers.Reshape((9, 9, 15))(output)

output = layers.Dense(5,name = "Fc_after_2")(output)

model = Model([img_input, true_boxes], output)

def custom_loss(y_true,y_pred):
    loss = tf.reduce_mean(y_true[0,:,0:,0:1]*tf.squared_difference(y_true[0,:,0:,1:5],y_pred[0,:,0:,1:5]))
    conf_loss = tf.reduce_mean(tf.squared_difference(y_true[0,:,0:,0:1],y_pred[0,:,0:,0:1]))
    return loss+conf_loss
# def custom_acc(y_true,y_pred):
#     loss = y_true[0,:,0:,0:1]*tf.squared_difference(y_true[0,:,0:,1:5],y_pred[0,:,0:,1:5])
#     conf_loss = tf.squared_difference(y_true[0,:,0:,0:1],y_pred[0,:,0:,0:1])
    
    
#model = Model([img_input, true_boxes], output)

model.load_weights('classifier_weights.h5',by_name=True)
optimizer = Adam(lr=0.5e-4, beta_1=0.9, beta_2=0.999, epsilon=1e-08, decay=0.0)
model.compile(loss=custom_loss, optimizer=optimizer,metrics=['accuracy'])

#model.summary()

#loading data
X = np.load('X/2007_test.npy')
Y = np.load('Y/2007_test_labels.npy')
box_ = np.load('default_all_boxes_new.npy')

def bxx(box,sh):
    boxx = np.zeros(shape=(sh,9,9,3,4))
    for i in range(sh):
        boxx[i]=box
    return boxx

train_X = X[0:4500]
train_Y = Y[0:4500]
test_X = X[4500:]
test_Y = Y[4500:]
box_train = bxx(box_,train_X.shape[0])
box_test = bxx(box_,test_X.shape[0])

print("train x: ",train_X.shape)
print("train y: ",train_Y.shape)
print("test x: ",test_X.shape)
print("test y: ",test_Y.shape)
print("boxes train: ",box_train.shape)
print("boxes test: ",box_test.shape)

history0 = model.fit([train_X,box_train],
                      train_Y,
                      batch_size=1,
                      epochs=1,
                      validation_data=([test_X,box_test],test_Y),
                      verbose=1)

#model.fit([train_X,box_],train_Y,epochs=5,validation_data=([test_X,box_],test_Y),verbose=1)

history1 = model.fit([train_X,box_train],
                      train_Y,
                      batch_size=16,
                      epochs=10,
                      validation_data=([test_X,box_test],test_Y),
                      verbose=1)

history2 = model.fit([train_X,box_train],
            train_Y,
            batch_size=32,
            epochs=10,
            validation_data=([test_X,box_test],test_Y),
            verbose=1)





